
https://github.com/goshlanguage/isometric
isometricエンジン
Ren'py
https://note.com/homtan/n/n938af8b0297f

https://www.youtube.com/watch?v=gE2gTCwLdFM&list=PLX5fBCkxJmm3s5GL0Cebm59m1GkAhCFoM&index=10


isometricなマス目を管理する

マップを定義する

マスのサイズ
マスの個数


その条件下でNPCの定義

npcのサイズ
npcの移動可能なマスの定義













animation_framesは、キャラクターが1歩動くのに必要なフレーム数を表します。この値が大きいほど、キャラクターの歩行アニメーションは滑らかになりますが、一方でキャラクターが1歩進むのに時間がかかります。

move_framesは、キャラクターが次の位置に移動するまでのフレーム数を表します。この値が大きいほど、キャラクターの移動速度は遅くなります。

これらの値の設定は、ゲームの雰囲気やプレイヤーの操作感に大きく影響します。例えば、アクションゲームではキャラクターの動きが速く、反応が良いことが求められるため、animation_framesとmove_framesの値は小さく設定することが一般的です。一方、ストラテジーゲームやRPGでは、キャラクターの動きがゆっくりとしていても問題ないため、これらの値を大きく設定することもあります。

最適な値はゲームの種類や目指すゲーム体験によりますので、様々な値を試してみて、最も適した設定を見つけることをお勧めします。具体的な値の範囲としては、animation_framesは5～20、move_framesは30～120程度が一般的ですが、これはあくまで一例であり、ゲームの要件によります。よろしくお願いいたします



animation_framesとmove_framesはフレーム数を表す値であり、直接的には時間（ミリ秒）を表していません。しかし、これらの値は間接的に時間を制御します。なぜなら、ゲームのフレームレート（FPS: Frames Per Second）が一定である場合、フレーム数は時間と直接的に関連しているからです。

例えば、ゲームが60FPSで動作しているとします。この場合、1フレームは約16.67ミリ秒（1000ミリ秒/60）に相当します。したがって、animation_framesが10であれば、1歩のアニメーションは約167ミリ秒（16.67ミリ秒*10）かかります。

ただし、この計算はゲームが常に目標のフレームレートを維持できるという前提に基づいています。もしゲームのパフォーマンスが下がり、フレームレートが低下した場合、実際の時間はこれよりも長くなります。

したがって、animation_framesやmove_framesを設定する際は、ゲームのフレームレートを考慮に入れることが重要です。これらの値をミリ秒で考えるのであれば、目標のフレームレートを用いて適切なフレーム数を計算することができます。例えば、アニメーションを200ミリ秒で完了させたい場合、60FPSのゲームではanimation_framesを12（200/16.67）に設定します。よろしくお願いいたします















順序を考え直す。整理する。
メインループから、update_sceneが実行されるのですが、
まだ、NPCとタイルしかないし、この上にUIの入力系と、きちんと動作するカメラを加える必要があるのです。
もっと言えば、入力後にゲーム内の値を計算処理も行う必要があるのです。


クラスの導入:
Map, NPC, Camera など、それぞれの概念に対するクラスを作成します。
これにより、関連する変数とメソッドをまとめ、コードをより構造化できます。

画像の読み込みの自動化:
NPC画像の読み込みを自動化するための関数を作成します。
これにより、新しいNPC画像が追加されたときに手動でコードを変更する必要がなくなります。

モジュールの分割:
大規模なプログラムでは、機能ごとにモジュールを分割することが役立ちます。
例えば、ゲームの状態を管理するモジュールや、画像の読み込みを管理するモジュールなどです。

入力処理の追加:
ゲーム内の値を計算するための入力処理を追加します。例えば、キー入力やマウスのクリックに対する処理を実装します。






画面上の異なる要素（マップ、NPC、UIなど）をうまく管理する


エンティティ(Entity)の管理:
マップ: マップのデータと描画を管理するクラスや関数を作成します。タイルごとの属性、位置情報などを持ちます。
NPC: NPCもエンティティなので、位置、アニメーション状態、属性などを持つクラスを作成します。NPCの移動やアニメーションはこのクラスで管理します。
UI: ゲームUIもエンティティとして管理します。ボタンやテキストなどが含まれます。

レイヤーの管理:
各要素を異なるレイヤーで管理します。通常、背景（マップ）は奥に、NPCやプレイヤーはその上に、UIは最前面に配置します。
描画する際に、背景→NPC→UIの順で描画することで、立体感が出て、UIが最前面に表示されます。

マネージャの使用:
各エンティティやレイヤーに対して、マネージャを使用すると便利です。
例えば、エンティティマネージャやレイヤーマネージャを作成し、それぞれの追加、削除、更新、描画などを管理します。

イベントの処理:
ゲーム内でのイベント（クリック、キー入力など）を適切に処理します。
これにより、プレイヤーが画面上で何かをクリックしたときに、該当するイベントをトリガーして対応する処理を行います。



タイルの描画について:
タイルの描画は、現在のコードでは isometric_tiles という辞書を使って、
tilemap の各要素に対応するイソメトリックなタイルを描画しています。
このアプローチは基本的に正しいですが、以下の点に留意する必要があります。

タイルの位置とサイズの計算:
タイルを正しい位置に描画するには、x および y 座標を正しく計算する必要があります。
isometric_size がタイルのサイズを表しているため、それを使用して正確な位置を計算してください。

isometric_tilesの描画順序:
タイルの描画順序には注意が必要です。上のレイヤーから下のレイヤーに描画されるようにすることで、立体感が出ます。
また、NPCなどの要素がタイルの上に描かれるように順序を制御してください。

NPCの描画について:
NPCの描画も現在のコードでは animation_list というリストを使って、NPCのアニメーションを制御しています。
このアプローチは基本的に正しいですが、以下の点に留意する必要があります。

NPCの位置の計算:
NPCの位置を正しく計算することが重要です。NPCの位置情報とアニメーションに基づいて、正確な位置を計算して描画してください。

アニメーションの管理:
アニメーションはNPCごとに管理されていますが、アニメーションの進行状況や方向などをうまく管理して描画してください。
アニメーションが正しく進まない場合、描画が乱れる可能性があります。

NPCの描画順序:
NPCの描画順序も考慮してください。NPCが他の要素の前に描画されるように制御してください。

改善案については、以下の点に留意しながらコードを修正することが重要です。
その際に、NPCやタイルの位置計算、描画順序、アニメーションの進行管理などを重点的に確認してください。














現在処理の順番
・計測

・画面変更があった部分のレクトの初期化

・フレームカウントがムーブフレームに達したら
  ・NPCの移動処理、変更があった部分のレクトの更新

・画面を黒で塗りつぶし、前回のフレームがクリアされる

・マップ上のセルごとに、対応するタイルが描画される、背景が描画される

・NPCの描画

・NPCが移動した部分のレクトの更新

・画面の更新
・フレームレート制御６０
・フレームカウントの更新
・カメラ位置の更新

・計測終了





















xの計算
(npc['position'][0] + (MAPHEIGHT - npc['position'][1])) * isometric_size // 2 - camera_x
npc['position'][0]: NPCのX座標
npc['position'][1]: NPCのY座標

(MAPHEIGHT - npc['position'][1]): Y座標を上下反転している（等角投影においてはY座標を逆さまにすることがよくあります）

positionは マップの座標。
Y軸が下が正で上が負





マップ


(npc['position'][0] + (MAPHEIGHT - npc['position'][1])): 上記の2つを足し合わせている
(npc['position'][0] + (MAPHEIGHT - npc['position'][1])) * isometric_size: 等角投影を考慮しています
(npc['position'][0] + (MAPHEIGHT - npc['position'][1])) * isometric_size // 2: 2で割っている（具体的な理由は不明）
- camera_x: カメラのX座標を考慮しています

x(npcx + npc y座標 * 考慮)












ご質問いただきありがとうございます。おそらく、この問題はPygameのイベントループの仕組みに関連していると思われます。Pygameは、ユーザーからの入力（キーボード、マウスなど）やシステムからの信号（ウィンドウを閉じるなど）を「イベント」としてキューに追加します。そして、pygame.event.get()を呼び出すと、これらのイベントが順番に処理されます。

あなたのコードでは、pygame.event.get()がゲームループの中で呼び出されています。これは、新しいイベントがキューに追加されるたびにゲームの状態を更新するためです。しかし、もし新しいイベントがなければ（つまり、マウスが動かされていない場合など）、pygame.event.get()は空のリストを返し、ゲームループは次のイテレーションに移ります。

このため、マウスが動かされていないときにゲームの状態が更新されないのではないかと考えられます。これを解決するためには、ゲームの状態更新と画面の再描画をイベント処理とは独立して行うようにコードを修正する必要があります。具体的には、ゲームの状態更新と画面の再描画をイベントループの外側（つまり、for event in pygame.event.get():の外側）で行うようにします。

これにより、新しいイベントがないときでもゲームの状態が定期的に更新され、画面が再描画されるようになるはずです。この修正が問題を解決するかどうか試してみてください。それでも問題が解決しない場合は、再度お知らせください。😊


    # カメラの位置をマウスの位置にゆっくり追従
    mouse_x, mouse_y = pygame.mouse.get_pos()
    camera_x = lerp(camera_x, mouse_x, camera_speed)
    camera_y = lerp(camera_y, mouse_y, camera_speed)